<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <link rel="stylesheet" href="style.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#000000" />
  <link rel="manifest" href="manifest.webmanifest" />
  <link rel="icon" href="icon-192.png" />
  <title>rescued.art</title>

  <!-- Square look + small UI tweaks -->
  <style>
    /* --- square everything (override any radii from style.css) --- */
    *, *::before, *::after { border-radius: 0 !important; }
    .tile, .imgwrap, .bigimg, .sheet, .btn, .close, .hint, .photos-count { border-radius: 0 !important; }

    body {
      margin: 0;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: #fff;
    }

    /* keep your compact top grid style for the “gallery” section if you still use fetchItems() */
    .grid-compact {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 4px;
      padding: 4px;
    }
    .tile {
      position: relative;
      overflow: hidden;
      background: #111;
    }
    .imgwrap { position: relative; width: 100%; padding-top: 100%; overflow: hidden; background: #0f0f12; }
    .tile img {
      position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; display: block;
    }
    .hint, .photos-count {
      position: absolute; top: 6px; left: 6px;
      background: rgba(0,0,0,0.55); padding: 4px 6px; font-size: 12px;
    }

    /* desktop-only glass arrows on tiles */
    .tile .arrow {
      position: absolute; top: 50%; transform: translateY(-50%);
      padding: 10px 12px; background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.18);
      backdrop-filter: blur(8px);
      cursor: pointer; user-select: none;
      opacity: 0; transition: opacity 130ms ease;
    }
    .tile:hover .arrow { opacity: 1; }
    .tile .arrow.left { left: 6px; }
    .tile .arrow.right { right: 6px; }
    .tile .arrow svg { display: block; width: 16px; height: 16px; }

    /* only show arrows on devices with a fine pointer (desktops/laptops) */
    @media (pointer: coarse) {
      .tile .arrow { display: none; }
    }

    /* overlay (popup) */
    .overlay { position: fixed; inset: 0; background: rgba(0,0,0,.65); display: none; align-items: center; justify-content: center; }
    .sheet   { background:#0f0f12; border:1px solid #2a2a2e; padding:16px; width:min(860px,94vw); color:#eaeaf0; }
    .sheet h2 { margin: 0 0 8px 0; font-size: 1rem; display:flex; justify-content:space-between; align-items:center; }
    /* hide the old title (gallery.js used to put the token here) */
    #ov-title { display: none; }

    .viewer {
      position: relative; width: 100%; height: min(78vh, 72vw); background: #0b0b0c;
      display: flex; align-items: center; justify-content: center;
    }
    .bigimg { max-width: 100%; max-height: 100%; width: auto; height: auto; object-fit: contain; }

    .ov-controls {
      display: flex; align-items: center; justify-content: space-between; gap: 12px; margin-top: 8px;
    }
    .counter { font-size: .95rem; color: #cfd2d9; letter-spacing: .3px; }

    /* glass arrows for overlay (desktop only) */
    .ov-arrow {
      position: absolute; top: 50%; transform: translateY(-50%);
      padding: 12px 14px; background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.18);
      backdrop-filter: blur(8px);
      cursor: pointer; user-select: none;
    }
    .ov-arrow.left  { left: 10px; }
    .ov-arrow.right { right: 10px; }
    .ov-arrow svg { display:block; width:18px; height:18px; }

    @media (pointer: coarse) {
      .ov-arrow { display: none; } /* swipe on touch devices; no arrows */
    }

    .close { border:none; background:#222; color:#ccc; padding:6px 10px; cursor:pointer; }
    .sentinel { height: 1px; }

    /* main grid that drives infinite scroll */
    .grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(160px,1fr)); gap:10px; padding:10px; }
    .meta { display:flex; justify-content:space-between; align-items:center; padding:8px 10px; font-size:.85rem; color:#bbb; }
    .meta .count { color:#9aa0a6; }
  </style>
</head>

<body>
  <main>
    <div id="grid" class="grid" aria-live="polite"></div>
    <div id="sentinel" class="sentinel" aria-hidden="true"></div>
  </main>

  <!-- (Optional) legacy gallery block from your original index; safe to remove if not used -->
  <div class="grid-compact" id="gallery" hidden></div>

  <!-- Overlay / popup -->
  <div id="overlay" class="overlay">
    <div class="sheet" role="dialog" aria-modal="true" aria-labelledby="ov-title">
      <h2>
        <span id="ov-title">Photo</span>
        <button id="ov-close" class="close" aria-label="Close">Close</button>
      </h2>

      <div class="viewer">
        <button class="ov-arrow left" id="ov-prev" aria-label="Previous">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/></svg>
        </button>
        <img id="ov-img" class="bigimg" alt="" />
        <button class="ov-arrow right" id="ov-next" aria-label="Next">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 6l6 6-6 6"/></svg>
        </button>
      </div>

      <div class="ov-controls">
        <div class="counter" id="ov-counter">—</div>
      </div>
    </div>
  </div>

  <script>
    // === CONFIG (copied from your existing setup) ===
    // Use the EXEC endpoint used by gallery.js; keeps your paging/data format.
    const EXEC = 'https://script.google.com/macros/s/AKfycbyh2wrTXGhKAkoCEqt_ZN2HzoSX6w360OMcLw9hBP5Mn35uX7-hS1WBTahXyLZpvJEE/exec';
    const PAGE_SIZE = 24;

    // Helpers (same behavior as in gallery.js)
    function fileIdFromUc(url){ const m=(url||'').match(/[?&]id=([^&]+)/); return m?m[1]:''; }
    function lh3Url(id,w=1600){ return id ? `https://lh3.googleusercontent.com/d/${id}=w${w}` : ''; }
    function imageUrlAt(item,i,w=1600){ return lh3Url(fileIdFromUc(item.imageUrls[i] || ''), w); }
    const isTouch = matchMedia('(pointer: coarse)').matches;

    // Lazy thumbnails
    const lazyObserver = new IntersectionObserver((entries)=>{
      for (const ent of entries) {
        if (!ent.isIntersecting) continue;
        const img = ent.target;
        if (img.dataset.src) { img.src = img.dataset.src; img.removeAttribute('data-src'); }
        lazyObserver.unobserve(img);
      }
    }, { rootMargin: '300px' });
    function lazyThumb(img, src){ img.dataset.src = src; lazyObserver.observe(img); }

    const grid = document.getElementById('grid');
    const sentinel = document.getElementById('sentinel');

    // --- Overlay state ---
    const overlay = document.getElementById('overlay');
    const ovImg = document.getElementById('ov-img');
    const ovCounter = document.getElementById('ov-counter');
    const btnClose = document.getElementById('ov-close');
    const btnPrev = document.getElementById('ov-prev');
    const btnNext = document.getElementById('ov-next');

    let currentItem = null;
    let currentIndex = 0;

    btnClose.onclick = () => overlay.style.display = 'none';

    function showOverlay(item, index=0){
      currentItem = item;
      currentIndex = index;
      updateOverlay();
      overlay.style.display = 'flex';
    }
    function updateOverlay(){
      if (!currentItem) return;
      ovImg.src = imageUrlAt(currentItem, currentIndex, 1600);
      ovCounter.textContent = `Photo ${currentIndex+1} of ${currentItem.imageUrls.length}`;
    }
    function prevOverlay(){ if (!currentItem) return; currentIndex = (currentIndex - 1 + currentItem.imageUrls.length) % currentItem.imageUrls.length; updateOverlay(); }
    function nextOverlay(){ if (!currentItem) return; currentIndex = (currentIndex + 1) % currentItem.imageUrls.length; updateOverlay(); }

    btnPrev.addEventListener('click', prevOverlay);
    btnNext.addEventListener('click', nextOverlay);

    // Mobile-only swipe in overlay
    if (isTouch) {
      let startX = null;
      ovImg.addEventListener('touchstart', e => { startX = e.touches[0].clientX; }, { passive: true });
      ovImg.addEventListener('touchmove', e => {
        if (startX == null) return;
        const dx = e.touches[0].clientX - startX;
        if (Math.abs(dx) > 40) {
          if (dx > 0) prevOverlay(); else nextOverlay();
          startX = e.touches[0].clientX;
        }
      }, { passive: true });
    }

    // Build one tile (square, with desktop arrows; swipe only on mobile)
    function makeTile(item){
      const t = document.createElement('div'); t.className='tile'; t.dataset.index='0';

      const wrap = document.createElement('div'); wrap.className='imgwrap';
      const img = document.createElement('img');
      lazyThumb(img, imageUrlAt(item, 0, 400));
      img.alt = ''; img.loading='lazy'; img.decoding='async';
      const hint = document.createElement('div'); hint.className='hint';
      hint.textContent = `${item.count} photo${item.count>1?'s':''}${isTouch?' — swipe':''}`;
      wrap.append(img, hint);

      // Desktop arrows visible only when (pointer: fine)
      const left = document.createElement('button'); left.className='arrow left'; left.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/></svg>';
      const right = document.createElement('button'); right.className='arrow right'; right.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 6l6 6-6 6"/></svg>';

      function change(delta){
        const n = item.imageUrls.length;
        const idx = +t.dataset.index || 0;
        const next = (idx + delta + n) % n;
        t.dataset.index = String(next);
        const nextUrl = imageUrlAt(item, next, 400);
        if (img.dataset.src !== nextUrl) { img.dataset.src = nextUrl; lazyObserver.observe(img); }
      }

      left.addEventListener('click', (e)=>{ e.stopPropagation(); change(-1); });
      right.addEventListener('click', (e)=>{ e.stopPropagation(); change(1); });

      // Mobile swipe only
      if (isTouch) {
        let startX=null;
        wrap.addEventListener('touchstart',e=>{startX=e.touches[0].clientX;},{passive:true});
        wrap.addEventListener('touchmove',e=>{
          if(startX==null) return;
          const dx=e.touches[0].clientX-startX;
          if(Math.abs(dx)>40){ change(dx>0?-1:1); startX=e.touches[0].clientX; }
        },{passive:true});
      }

      // Click opens overlay (no ID shown)
      t.addEventListener('click', ()=>{
        const idx = +t.dataset.index || 0;
        showOverlay(item, idx);
      });

      // meta row (keeps count but no token/ID)
      const meta = document.createElement('div'); meta.className='meta';
      meta.innerHTML = `<span class="count">${item.count} photo${item.count>1?'s':''}</span>`;
      t.append(wrap, left, right, meta);
      return t;
    }

    // Infinite paging (no caching on first page)
    let nextPage = 1, hasMore = true, loading = false;
    async function loadNextPage({nocache=false} = {}) {
      if (loading || !hasMore) return; loading = true;
      try {
        const url = `${EXEC}?api=items&page=${nextPage}&pageSize=${PAGE_SIZE}${nocache?'&nocache=1':''}`;
        const res = await fetch(url, { cache:'no-store' });
        const data = await res.json();

        if (Array.isArray(data.items)) data.items.forEach(it => grid.appendChild(makeTile(it)));
        hasMore = !!data.hasMore; nextPage += 1;
        if (!hasMore) pageObserver.unobserve(sentinel);
      } catch (err) {
        console.error('Page load failed', err);
      } finally { loading = false; }
    }
    const pageObserver = new IntersectionObserver((entries)=>{
      if (entries.some(e=>e.isIntersecting)) loadNextPage();
    }, { rootMargin:'800px' });

    (async function boot(){
      await loadNextPage({ nocache: true });
      pageObserver.observe(sentinel);
    })();

    // --- If you still want the old fetchItems() block, it’s kept & hidden; safe to remove. ---
    const API_URL = 'https://script.google.com/macros/s/AKfycbzXYKl5Wi1iOplK9d4mZNHtg-H70H9lb07JkitkPrl0Zb7pVoh8sPYWTxzicUtlE-a4/exec';
    async function fetchItems() {
      try {
        const res = await fetch(API_URL);
        const data = await res.json();
        if (!data.ok) return;
        const gallery = document.getElementById('gallery');
        gallery.innerHTML = '';
        data.items.forEach(item => {
          const div = document.createElement('div');
          div.className = 'tile';
          div.innerHTML = `
            <div class="photos-count">${item.count} photos${isTouch?' — swipe':''}</div>
            <img src="${item.coverUrl}" alt="">
          `;
          gallery.appendChild(div);
        });
      } catch {}
    }
    // fetchItems(); // not used by default
  </script>
</body>
</html>
